"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/identify";
exports.ids = ["pages/api/identify"];
exports.modules = {

/***/ "(api)/./pages/api/identify.js":
/*!*******************************!*\
  !*** ./pages/api/identify.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _utils_openRouterApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/openRouterApi */ \"(api)/./utils/openRouterApi.js\");\n/* harmony import */ var _utils_memoryDb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/memoryDb */ \"(api)/./utils/memoryDb.js\");\n/* harmony import */ var _utils_imageProcessing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/imageProcessing */ \"(api)/./utils/imageProcessing.js\");\n\n\n\n// Configure Next.js API route to handle larger payloads\nconst config = {\n    api: {\n        bodyParser: {\n            sizeLimit: \"10mb\"\n        }\n    }\n};\nasync function handler(req, res) {\n    // Only allow POST requests\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method not allowed\"\n        });\n    }\n    try {\n        console.log(\"API request received:\", req.method, req.url);\n        const { image } = req.body;\n        console.log(\"Image data received:\", image ? `${typeof image} (length: ${image.length})` : \"null\");\n        if (!image) {\n            return res.status(400).json({\n                message: \"No image provided\"\n            });\n        }\n        // Process image for server-side use (extract base64 content)\n        const processedImage = await (0,_utils_imageProcessing__WEBPACK_IMPORTED_MODULE_2__.processImageServerSide)(image);\n        console.log(\"Processed image size:\", processedImage.length);\n        // Call OpenRouter API for identification\n        console.log(\"Calling OpenRouter API...\");\n        try {\n            const identificationResults = await (0,_utils_openRouterApi__WEBPACK_IMPORTED_MODULE_0__.identifyWithOpenRouter)(processedImage);\n            // Extract results\n            if (!identificationResults || !identificationResults.identification) {\n                return res.status(500).json({\n                    message: \"Failed to identify the image. The AI service returned an invalid response.\"\n                });\n            }\n            // Store in history (keep original image for display)\n            const historyItem = {\n                id: Date.now().toString(),\n                timestamp: new Date().toISOString(),\n                imageData: image,\n                results: identificationResults,\n                type: identificationResults.identification.category // 'plant' or 'animal'\n            };\n            (0,_utils_memoryDb__WEBPACK_IMPORTED_MODULE_1__.addToHistory)(historyItem);\n            // Return results to client\n            return res.status(200).json(identificationResults);\n        } catch (identifyError) {\n            console.error(\"OpenRouter identification error:\", identifyError);\n            return res.status(500).json({\n                message: `Failed to identify with AI service: ${identifyError.message}`\n            });\n        }\n    } catch (error) {\n        console.error(\"General identification error:\", error);\n        return res.status(500).json({\n            message: `Failed to process image: ${error.message || \"Unknown error\"}`\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvaWRlbnRpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUU7QUFDZjtBQUNpQjtBQUVyRSx3REFBd0Q7QUFDakQsTUFBTUcsU0FBUztJQUNwQkMsS0FBSztRQUNIQyxZQUFZO1lBQ1ZDLFdBQVc7UUFDYjtJQUNGO0FBQ0YsRUFBRTtBQUVhLGVBQWVDLFFBQVFDLEdBQUcsRUFBRUMsR0FBRztJQUM1QywyQkFBMkI7SUFDM0IsSUFBSUQsSUFBSUUsV0FBVyxRQUFRO1FBQ3pCLE9BQU9ELElBQUlFLE9BQU8sS0FBS0MsS0FBSztZQUFFQyxTQUFTO1FBQXFCO0lBQzlEO0lBRUEsSUFBSTtRQUNGQyxRQUFRQyxJQUFJLHlCQUF5QlAsSUFBSUUsUUFBUUYsSUFBSVE7UUFDckQsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR1QsSUFBSVU7UUFFdEJKLFFBQVFDLElBQUksd0JBQXdCRSxRQUNsQyxDQUFDLEVBQUUsT0FBT0EsTUFBTSxVQUFVLEVBQUVBLE1BQU1FLE9BQU8sQ0FBQyxDQUFDLEdBQUc7UUFFaEQsSUFBSSxDQUFDRixPQUFPO1lBQ1YsT0FBT1IsSUFBSUUsT0FBTyxLQUFLQyxLQUFLO2dCQUFFQyxTQUFTO1lBQW9CO1FBQzdEO1FBRUEsNkRBQTZEO1FBQzdELE1BQU1PLGlCQUFpQixNQUFNbEIsOEVBQXNCQSxDQUFDZTtRQUNwREgsUUFBUUMsSUFBSSx5QkFBeUJLLGVBQWVEO1FBRXBELHlDQUF5QztRQUN6Q0wsUUFBUUMsSUFBSTtRQUVaLElBQUk7WUFDRixNQUFNTSx3QkFBd0IsTUFBTXJCLDRFQUFzQkEsQ0FBQ29CO1lBRTNELGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLHlCQUF5QixDQUFDQSxzQkFBc0JDLGdCQUFnQjtnQkFDbkUsT0FBT2IsSUFBSUUsT0FBTyxLQUFLQyxLQUFLO29CQUMxQkMsU0FBUztnQkFDWDtZQUNGO1lBRUEscURBQXFEO1lBQ3JELE1BQU1VLGNBQWM7Z0JBQ2xCQyxJQUFJQyxLQUFLQyxNQUFNQztnQkFDZkMsV0FBVyxJQUFJSCxPQUFPSTtnQkFDdEJDLFdBQVdiO2dCQUNYYyxTQUFTVjtnQkFDVFcsTUFBTVgsc0JBQXNCQyxlQUFlVyxTQUFTLHNCQUFzQjtZQUM1RTtZQUVBaEMsNkRBQVlBLENBQUNzQjtZQUViLDJCQUEyQjtZQUMzQixPQUFPZCxJQUFJRSxPQUFPLEtBQUtDLEtBQUtTO1FBQzlCLEVBQUUsT0FBT2EsZUFBZTtZQUN0QnBCLFFBQVFxQixNQUFNLG9DQUFvQ0Q7WUFDbEQsT0FBT3pCLElBQUlFLE9BQU8sS0FBS0MsS0FBSztnQkFDMUJDLFNBQVMsQ0FBQyxvQ0FBb0MsRUFBRXFCLGNBQWNyQixRQUFRLENBQUM7WUFDekU7UUFDRjtJQUNGLEVBQUUsT0FBT3NCLE9BQU87UUFDZHJCLFFBQVFxQixNQUFNLGlDQUFpQ0E7UUFDL0MsT0FBTzFCLElBQUlFLE9BQU8sS0FBS0MsS0FBSztZQUMxQkMsU0FBUyxDQUFDLHlCQUF5QixFQUFFc0IsTUFBTXRCLFdBQVcsZ0JBQWdCLENBQUM7UUFDekU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vcGFnZXMvYXBpL2lkZW50aWZ5LmpzPzJhNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaWRlbnRpZnlXaXRoT3BlblJvdXRlciB9IGZyb20gJy4uLy4uL3V0aWxzL29wZW5Sb3V0ZXJBcGknO1xuaW1wb3J0IHsgYWRkVG9IaXN0b3J5IH0gZnJvbSAnLi4vLi4vdXRpbHMvbWVtb3J5RGInO1xuaW1wb3J0IHsgcHJvY2Vzc0ltYWdlU2VydmVyU2lkZSB9IGZyb20gJy4uLy4uL3V0aWxzL2ltYWdlUHJvY2Vzc2luZyc7XG5cbi8vIENvbmZpZ3VyZSBOZXh0LmpzIEFQSSByb3V0ZSB0byBoYW5kbGUgbGFyZ2VyIHBheWxvYWRzXG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBhcGk6IHtcbiAgICBib2R5UGFyc2VyOiB7XG4gICAgICBzaXplTGltaXQ6ICcxMG1iJywgLy8gSW5jcmVhc2UgdGhlIGJvZHkgcGFyc2VyIGxpbWl0IGZvciBpbWFnZSB1cGxvYWRzXG4gICAgfSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMpIHtcbiAgLy8gT25seSBhbGxvdyBQT1NUIHJlcXVlc3RzXG4gIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBtZXNzYWdlOiAnTWV0aG9kIG5vdCBhbGxvd2VkJyB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCJBUEkgcmVxdWVzdCByZWNlaXZlZDpcIiwgcmVxLm1ldGhvZCwgcmVxLnVybCk7XG4gICAgY29uc3QgeyBpbWFnZSB9ID0gcmVxLmJvZHk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkltYWdlIGRhdGEgcmVjZWl2ZWQ6XCIsIGltYWdlID8gXG4gICAgICBgJHt0eXBlb2YgaW1hZ2V9IChsZW5ndGg6ICR7aW1hZ2UubGVuZ3RofSlgIDogXCJudWxsXCIpO1xuXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgbWVzc2FnZTogJ05vIGltYWdlIHByb3ZpZGVkJyB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGltYWdlIGZvciBzZXJ2ZXItc2lkZSB1c2UgKGV4dHJhY3QgYmFzZTY0IGNvbnRlbnQpXG4gICAgY29uc3QgcHJvY2Vzc2VkSW1hZ2UgPSBhd2FpdCBwcm9jZXNzSW1hZ2VTZXJ2ZXJTaWRlKGltYWdlKTtcbiAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NlZCBpbWFnZSBzaXplOlwiLCBwcm9jZXNzZWRJbWFnZS5sZW5ndGgpO1xuICAgICAgXG4gICAgLy8gQ2FsbCBPcGVuUm91dGVyIEFQSSBmb3IgaWRlbnRpZmljYXRpb25cbiAgICBjb25zb2xlLmxvZyhcIkNhbGxpbmcgT3BlblJvdXRlciBBUEkuLi5cIik7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpY2F0aW9uUmVzdWx0cyA9IGF3YWl0IGlkZW50aWZ5V2l0aE9wZW5Sb3V0ZXIocHJvY2Vzc2VkSW1hZ2UpO1xuXG4gICAgICAvLyBFeHRyYWN0IHJlc3VsdHNcbiAgICAgIGlmICghaWRlbnRpZmljYXRpb25SZXN1bHRzIHx8ICFpZGVudGlmaWNhdGlvblJlc3VsdHMuaWRlbnRpZmljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBpZGVudGlmeSB0aGUgaW1hZ2UuIFRoZSBBSSBzZXJ2aWNlIHJldHVybmVkIGFuIGludmFsaWQgcmVzcG9uc2UuJyBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGluIGhpc3RvcnkgKGtlZXAgb3JpZ2luYWwgaW1hZ2UgZm9yIGRpc3BsYXkpXG4gICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IHtcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGltYWdlRGF0YTogaW1hZ2UsIC8vIFN0b3JlIG9yaWdpbmFsIGltYWdlIGZvciBiZXR0ZXIgcXVhbGl0eSBpbiBoaXN0b3J5IHZpZXdcbiAgICAgICAgcmVzdWx0czogaWRlbnRpZmljYXRpb25SZXN1bHRzLFxuICAgICAgICB0eXBlOiBpZGVudGlmaWNhdGlvblJlc3VsdHMuaWRlbnRpZmljYXRpb24uY2F0ZWdvcnkgLy8gJ3BsYW50JyBvciAnYW5pbWFsJ1xuICAgICAgfTtcblxuICAgICAgYWRkVG9IaXN0b3J5KGhpc3RvcnlJdGVtKTtcblxuICAgICAgLy8gUmV0dXJuIHJlc3VsdHMgdG8gY2xpZW50XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oaWRlbnRpZmljYXRpb25SZXN1bHRzKTtcbiAgICB9IGNhdGNoIChpZGVudGlmeUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdPcGVuUm91dGVyIGlkZW50aWZpY2F0aW9uIGVycm9yOicsIGlkZW50aWZ5RXJyb3IpO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gaWRlbnRpZnkgd2l0aCBBSSBzZXJ2aWNlOiAke2lkZW50aWZ5RXJyb3IubWVzc2FnZX1gIFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0dlbmVyYWwgaWRlbnRpZmljYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxuICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byBwcm9jZXNzIGltYWdlOiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWAgXG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpZGVudGlmeVdpdGhPcGVuUm91dGVyIiwiYWRkVG9IaXN0b3J5IiwicHJvY2Vzc0ltYWdlU2VydmVyU2lkZSIsImNvbmZpZyIsImFwaSIsImJvZHlQYXJzZXIiLCJzaXplTGltaXQiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwidXJsIiwiaW1hZ2UiLCJib2R5IiwibGVuZ3RoIiwicHJvY2Vzc2VkSW1hZ2UiLCJpZGVudGlmaWNhdGlvblJlc3VsdHMiLCJpZGVudGlmaWNhdGlvbiIsImhpc3RvcnlJdGVtIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsImltYWdlRGF0YSIsInJlc3VsdHMiLCJ0eXBlIiwiY2F0ZWdvcnkiLCJpZGVudGlmeUVycm9yIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/identify.js\n");

/***/ }),

/***/ "(api)/./utils/imageProcessing.js":
/*!**********************************!*\
  !*** ./utils/imageProcessing.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processImage: () => (/* binding */ processImage),\n/* harmony export */   processImageServerSide: () => (/* binding */ processImageServerSide)\n/* harmony export */ });\n/**\n * Utility functions for processing images before sending to AI\n */ /**\n * Process an image to ensure it's in a suitable format for the AI\n * @param {string} imageDataUrl - Base64 encoded image data URL\n * @returns {string} Processed image data URL\n */ async function processImage(imageDataUrl) {\n    try {\n        // Ensure we have a valid data URL\n        if (!imageDataUrl || !imageDataUrl.startsWith(\"data:image/\")) {\n            throw new Error(\"Invalid image data\");\n        }\n        // Create an image to load the data URL\n        const img = document.createElement(\"img\");\n        // Create a promise to handle the image loading\n        const imageLoaded = new Promise((resolve, reject)=>{\n            img.onload = ()=>resolve();\n            img.onerror = ()=>reject(new Error(\"Failed to load image\"));\n        });\n        // Set the source and start loading\n        img.src = imageDataUrl;\n        // Wait for the image to load\n        await imageLoaded;\n        // Create a canvas element for processing\n        const canvas = document.createElement(\"canvas\");\n        // Calculate dimensions (max 1024px width/height while preserving aspect ratio)\n        let { width, height } = img;\n        const MAX_DIMENSION = 1024;\n        if (width > MAX_DIMENSION || height > MAX_DIMENSION) {\n            if (width > height) {\n                height = Math.round(height * MAX_DIMENSION / width);\n                width = MAX_DIMENSION;\n            } else {\n                width = Math.round(width * MAX_DIMENSION / height);\n                height = MAX_DIMENSION;\n            }\n        }\n        // Set canvas dimensions\n        canvas.width = width;\n        canvas.height = height;\n        // Draw image on canvas with new dimensions\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0, width, height);\n        // Convert to JPEG and reduce quality to save bandwidth\n        const processedImageDataUrl = canvas.toDataURL(\"image/jpeg\", 0.85);\n        return processedImageDataUrl;\n    } catch (error) {\n        console.error(\"Image processing error:\", error);\n        // If something goes wrong, return the original image\n        return imageDataUrl;\n    }\n}\n/**\n * Server-side image processing function for the API route\n * @param {string} imageDataUrl - Base64 encoded image data URL\n * @returns {string} Processed image data URL\n */ async function processImageServerSide(imageDataUrl) {\n    try {\n        console.log(\"processImageServerSide received:\", typeof imageDataUrl === \"string\" ? `${imageDataUrl.substring(0, 50)}... (length: ${imageDataUrl.length})` : typeof imageDataUrl);\n        // Check if we have an image at all\n        if (!imageDataUrl) {\n            console.error(\"No image data provided to processImageServerSide\");\n            throw new Error(\"No image data provided\");\n        }\n        // Ensure we have a valid data URL\n        if (!imageDataUrl.startsWith(\"data:image/\")) {\n            console.error(\"Invalid image data format, expected data:image/ URL\");\n            // If it's not a data URL but still has content, we'll just return it as-is\n            // The API handler will deal with it\n            return imageDataUrl;\n        }\n        // For server-side processing, we'll just extract the base64 data\n        // and return it without the data URL prefix to save space\n        const parts = imageDataUrl.split(\",\");\n        if (parts.length !== 2) {\n            console.error(\"Invalid data URL format\");\n            return imageDataUrl;\n        }\n        // Return the full data URL to ensure compatibility with the API\n        // This is a change from previous code that tried to extract just the base64 part\n        console.log(\"Extracted base64 data length:\", parts[1].length);\n        return imageDataUrl;\n    } catch (error) {\n        console.error(\"Server-side image processing error:\", error);\n        // If something goes wrong, return the original data\n        return imageDataUrl;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9pbWFnZVByb2Nlc3NpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUVEOzs7O0NBSUMsR0FDTSxlQUFlQSxhQUFhQyxZQUFZO0lBQzdDLElBQUk7UUFDRixrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQ0EsYUFBYUMsV0FBVyxnQkFBZ0I7WUFDNUQsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsdUNBQXVDO1FBQ3ZDLE1BQU1DLE1BQU1DLFNBQVNDLGNBQWM7UUFFbkMsK0NBQStDO1FBQy9DLE1BQU1DLGNBQWMsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN4Q04sSUFBSU8sU0FBUyxJQUFNRjtZQUNuQkwsSUFBSVEsVUFBVSxJQUFNRixPQUFPLElBQUlQLE1BQU07UUFDdkM7UUFFQSxtQ0FBbUM7UUFDbkNDLElBQUlTLE1BQU1aO1FBRVYsNkJBQTZCO1FBQzdCLE1BQU1NO1FBRU4seUNBQXlDO1FBQ3pDLE1BQU1PLFNBQVNULFNBQVNDLGNBQWM7UUFFdEMsK0VBQStFO1FBQy9FLElBQUksRUFBRVMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBR1o7UUFDeEIsTUFBTWEsZ0JBQWdCO1FBRXRCLElBQUlGLFFBQVFFLGlCQUFpQkQsU0FBU0MsZUFBZTtZQUNuRCxJQUFJRixRQUFRQyxRQUFRO2dCQUNsQkEsU0FBU0UsS0FBS0MsTUFBTSxTQUFVRixnQkFBaUJGO2dCQUMvQ0EsUUFBUUU7WUFDVixPQUFPO2dCQUNMRixRQUFRRyxLQUFLQyxNQUFNLFFBQVNGLGdCQUFpQkQ7Z0JBQzdDQSxTQUFTQztZQUNYO1FBQ0Y7UUFFQSx3QkFBd0I7UUFDeEJILE9BQU9DLFFBQVFBO1FBQ2ZELE9BQU9FLFNBQVNBO1FBRWhCLDJDQUEyQztRQUMzQyxNQUFNSSxNQUFNTixPQUFPTyxXQUFXO1FBQzlCRCxJQUFJRSxVQUFVbEIsS0FBSyxHQUFHLEdBQUdXLE9BQU9DO1FBRWhDLHVEQUF1RDtRQUN2RCxNQUFNTyx3QkFBd0JULE9BQU9VLFVBQVUsY0FBYztRQUU3RCxPQUFPRDtJQUNULEVBQUUsT0FBT0UsT0FBTztRQUNkQyxRQUFRRCxNQUFNLDJCQUEyQkE7UUFFekMscURBQXFEO1FBQ3JELE9BQU94QjtJQUNUO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sZUFBZTBCLHVCQUF1QjFCLFlBQVk7SUFDdkQsSUFBSTtRQUNGeUIsUUFBUUUsSUFBSSxvQ0FDVixPQUFPM0IsaUJBQWlCLFdBQ3BCLENBQUMsRUFBRUEsYUFBYTRCLFVBQVUsR0FBRyxJQUFJLGFBQWEsRUFBRTVCLGFBQWE2QixPQUFPLENBQUMsQ0FBQyxHQUN0RSxPQUFPN0I7UUFFYixtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDQSxjQUFjO1lBQ2pCeUIsUUFBUUQsTUFBTTtZQUNkLE1BQU0sSUFBSXRCLE1BQU07UUFDbEI7UUFFQSxrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDRixhQUFhQyxXQUFXLGdCQUFnQjtZQUMzQ3dCLFFBQVFELE1BQU07WUFDZCwyRUFBMkU7WUFDM0Usb0NBQW9DO1lBQ3BDLE9BQU94QjtRQUNUO1FBRUEsaUVBQWlFO1FBQ2pFLDBEQUEwRDtRQUMxRCxNQUFNOEIsUUFBUTlCLGFBQWErQixNQUFNO1FBQ2pDLElBQUlELE1BQU1ELFdBQVcsR0FBRztZQUN0QkosUUFBUUQsTUFBTTtZQUNkLE9BQU94QjtRQUNUO1FBRUEsZ0VBQWdFO1FBQ2hFLGlGQUFpRjtRQUNqRnlCLFFBQVFFLElBQUksaUNBQWlDRyxLQUFLLENBQUMsRUFBRSxDQUFDRDtRQUV0RCxPQUFPN0I7SUFDVCxFQUFFLE9BQU93QixPQUFPO1FBQ2RDLFFBQVFELE1BQU0sdUNBQXVDQTtRQUNyRCxvREFBb0Q7UUFDcEQsT0FBT3hCO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtzcGFjZS8uL3V0aWxzL2ltYWdlUHJvY2Vzc2luZy5qcz9hYzkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHByb2Nlc3NpbmcgaW1hZ2VzIGJlZm9yZSBzZW5kaW5nIHRvIEFJXG4gKi9cblxuLyoqXG4gKiBQcm9jZXNzIGFuIGltYWdlIHRvIGVuc3VyZSBpdCdzIGluIGEgc3VpdGFibGUgZm9ybWF0IGZvciB0aGUgQUlcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGFVcmwgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gUHJvY2Vzc2VkIGltYWdlIGRhdGEgVVJMXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2UoaW1hZ2VEYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBkYXRhIFVSTFxuICAgIGlmICghaW1hZ2VEYXRhVXJsIHx8ICFpbWFnZURhdGFVcmwuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltYWdlIGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gaW1hZ2UgdG8gbG9hZCB0aGUgZGF0YSBVUkxcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRvIGhhbmRsZSB0aGUgaW1hZ2UgbG9hZGluZ1xuICAgIGNvbnN0IGltYWdlTG9hZGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UnKSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBzb3VyY2UgYW5kIHN0YXJ0IGxvYWRpbmdcbiAgICBpbWcuc3JjID0gaW1hZ2VEYXRhVXJsO1xuICAgIFxuICAgIC8vIFdhaXQgZm9yIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgYXdhaXQgaW1hZ2VMb2FkZWQ7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnQgZm9yIHByb2Nlc3NpbmdcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyAobWF4IDEwMjRweCB3aWR0aC9oZWlnaHQgd2hpbGUgcHJlc2VydmluZyBhc3BlY3QgcmF0aW8pXG4gICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1nO1xuICAgIGNvbnN0IE1BWF9ESU1FTlNJT04gPSAxMDI0O1xuICAgIFxuICAgIGlmICh3aWR0aCA+IE1BWF9ESU1FTlNJT04gfHwgaGVpZ2h0ID4gTUFYX0RJTUVOU0lPTikge1xuICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodCAqIE1BWF9ESU1FTlNJT04pIC8gd2lkdGgpO1xuICAgICAgICB3aWR0aCA9IE1BWF9ESU1FTlNJT047XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQoKHdpZHRoICogTUFYX0RJTUVOU0lPTikgLyBoZWlnaHQpO1xuICAgICAgICBoZWlnaHQgPSBNQVhfRElNRU5TSU9OO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnNcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIFxuICAgIC8vIERyYXcgaW1hZ2Ugb24gY2FudmFzIHdpdGggbmV3IGRpbWVuc2lvbnNcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBKUEVHIGFuZCByZWR1Y2UgcXVhbGl0eSB0byBzYXZlIGJhbmR3aWR0aFxuICAgIGNvbnN0IHByb2Nlc3NlZEltYWdlRGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjg1KTtcbiAgICBcbiAgICByZXR1cm4gcHJvY2Vzc2VkSW1hZ2VEYXRhVXJsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlIHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCByZXR1cm4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgcmV0dXJuIGltYWdlRGF0YVVybDtcbiAgfVxufVxuXG4vKipcbiAqIFNlcnZlci1zaWRlIGltYWdlIHByb2Nlc3NpbmcgZnVuY3Rpb24gZm9yIHRoZSBBUEkgcm91dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGFVcmwgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gUHJvY2Vzc2VkIGltYWdlIGRhdGEgVVJMXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VTZXJ2ZXJTaWRlKGltYWdlRGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdwcm9jZXNzSW1hZ2VTZXJ2ZXJTaWRlIHJlY2VpdmVkOicsIFxuICAgICAgdHlwZW9mIGltYWdlRGF0YVVybCA9PT0gJ3N0cmluZycgXG4gICAgICAgID8gYCR7aW1hZ2VEYXRhVXJsLnN1YnN0cmluZygwLCA1MCl9Li4uIChsZW5ndGg6ICR7aW1hZ2VEYXRhVXJsLmxlbmd0aH0pYCBcbiAgICAgICAgOiB0eXBlb2YgaW1hZ2VEYXRhVXJsKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIGltYWdlIGF0IGFsbFxuICAgIGlmICghaW1hZ2VEYXRhVXJsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyBpbWFnZSBkYXRhIHByb3ZpZGVkIHRvIHByb2Nlc3NJbWFnZVNlcnZlclNpZGUnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW1hZ2UgZGF0YSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIGRhdGEgVVJMXG4gICAgaWYgKCFpbWFnZURhdGFVcmwuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBpbWFnZSBkYXRhIGZvcm1hdCwgZXhwZWN0ZWQgZGF0YTppbWFnZS8gVVJMJyk7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBhIGRhdGEgVVJMIGJ1dCBzdGlsbCBoYXMgY29udGVudCwgd2UnbGwganVzdCByZXR1cm4gaXQgYXMtaXNcbiAgICAgIC8vIFRoZSBBUEkgaGFuZGxlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgcmV0dXJuIGltYWdlRGF0YVVybDtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHdlJ2xsIGp1c3QgZXh0cmFjdCB0aGUgYmFzZTY0IGRhdGFcbiAgICAvLyBhbmQgcmV0dXJuIGl0IHdpdGhvdXQgdGhlIGRhdGEgVVJMIHByZWZpeCB0byBzYXZlIHNwYWNlXG4gICAgY29uc3QgcGFydHMgPSBpbWFnZURhdGFVcmwuc3BsaXQoJywnKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCcpO1xuICAgICAgcmV0dXJuIGltYWdlRGF0YVVybDtcbiAgICB9XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBmdWxsIGRhdGEgVVJMIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIEFQSVxuICAgIC8vIFRoaXMgaXMgYSBjaGFuZ2UgZnJvbSBwcmV2aW91cyBjb2RlIHRoYXQgdHJpZWQgdG8gZXh0cmFjdCBqdXN0IHRoZSBiYXNlNjQgcGFydFxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgYmFzZTY0IGRhdGEgbGVuZ3RoOicsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgXG4gICAgcmV0dXJuIGltYWdlRGF0YVVybDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTZXJ2ZXItc2lkZSBpbWFnZSBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcmV0dXJuIHRoZSBvcmlnaW5hbCBkYXRhXG4gICAgcmV0dXJuIGltYWdlRGF0YVVybDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3NJbWFnZSIsImltYWdlRGF0YVVybCIsInN0YXJ0c1dpdGgiLCJFcnJvciIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltYWdlTG9hZGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJNQVhfRElNRU5TSU9OIiwiTWF0aCIsInJvdW5kIiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInByb2Nlc3NlZEltYWdlRGF0YVVybCIsInRvRGF0YVVSTCIsImVycm9yIiwiY29uc29sZSIsInByb2Nlc3NJbWFnZVNlcnZlclNpZGUiLCJsb2ciLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwYXJ0cyIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/imageProcessing.js\n");

/***/ }),

/***/ "(api)/./utils/memoryDb.js":
/*!***************************!*\
  !*** ./utils/memoryDb.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToHistory: () => (/* binding */ addToHistory),\n/* harmony export */   clearHistory: () => (/* binding */ clearHistory),\n/* harmony export */   deleteHistoryItem: () => (/* binding */ deleteHistoryItem),\n/* harmony export */   getHistory: () => (/* binding */ getHistory),\n/* harmony export */   getHistoryById: () => (/* binding */ getHistoryById)\n/* harmony export */ });\n/**\n * In-memory database for storing identification history\n * This is a simple implementation as per the blueprint requirements\n */ // Maximum history items to store (for free users)\nconst MAX_FREE_HISTORY_ITEMS = 10;\n// In-memory storage for identification history\nlet historyItems = [];\n/**\n * Add a new identification result to history\n * @param {Object} item - The identification result to add\n */ function addToHistory(item) {\n    // Add new item at the beginning of the array\n    historyItems.unshift(item);\n    // Limit history size for free users\n    if (historyItems.length > MAX_FREE_HISTORY_ITEMS) {\n        historyItems = historyItems.slice(0, MAX_FREE_HISTORY_ITEMS);\n    }\n}\n/**\n * Get history items, optionally filtered by type\n * @param {string} type - Filter type ('plant', 'animal', or 'all')\n * @returns {Array} Array of history items\n */ function getHistory(type = \"all\") {\n    if (type === \"all\") {\n        return [\n            ...historyItems\n        ];\n    }\n    return historyItems.filter((item)=>item.type === type);\n}\n/**\n * Clear all history items\n */ function clearHistory() {\n    historyItems = [];\n}\n/**\n * Get a specific history item by ID\n * @param {string} id - The ID of the history item to retrieve\n * @returns {Object|null} The history item or null if not found\n */ function getHistoryById(id) {\n    return historyItems.find((item)=>item.id === id) || null;\n}\n/**\n * Delete a specific history item by ID\n * @param {string} id - The ID of the history item to delete\n * @returns {boolean} True if deletion was successful, false otherwise\n */ function deleteHistoryItem(id) {\n    const initialLength = historyItems.length;\n    historyItems = historyItems.filter((item)=>item.id !== id);\n    return historyItems.length !== initialLength;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9tZW1vcnlEYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVELGtEQUFrRDtBQUNsRCxNQUFNQSx5QkFBeUI7QUFFL0IsK0NBQStDO0FBQy9DLElBQUlDLGVBQWUsRUFBRTtBQUVyQjs7O0NBR0MsR0FDTSxTQUFTQyxhQUFhQyxJQUFJO0lBQy9CLDZDQUE2QztJQUM3Q0YsYUFBYUcsUUFBUUQ7SUFFckIsb0NBQW9DO0lBQ3BDLElBQUlGLGFBQWFJLFNBQVNMLHdCQUF3QjtRQUNoREMsZUFBZUEsYUFBYUssTUFBTSxHQUFHTjtJQUN2QztBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNPLFdBQVdDLE9BQU8sS0FBSztJQUNyQyxJQUFJQSxTQUFTLE9BQU87UUFDbEIsT0FBTztlQUFJUDtTQUFhO0lBQzFCO0lBRUEsT0FBT0EsYUFBYVEsT0FBT04sQ0FBQUEsT0FBUUEsS0FBS0ssU0FBU0E7QUFDbkQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVNFO0lBQ2RULGVBQWUsRUFBRTtBQUNuQjtBQUVBOzs7O0NBSUMsR0FDTSxTQUFTVSxlQUFlQyxFQUFFO0lBQy9CLE9BQU9YLGFBQWFZLEtBQUtWLENBQUFBLE9BQVFBLEtBQUtTLE9BQU9BLE9BQU87QUFDdEQ7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0Usa0JBQWtCRixFQUFFO0lBQ2xDLE1BQU1HLGdCQUFnQmQsYUFBYUk7SUFDbkNKLGVBQWVBLGFBQWFRLE9BQU9OLENBQUFBLE9BQVFBLEtBQUtTLE9BQU9BO0lBQ3ZELE9BQU9YLGFBQWFJLFdBQVdVO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ya3NwYWNlLy4vdXRpbHMvbWVtb3J5RGIuanM/NTg2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEluLW1lbW9yeSBkYXRhYmFzZSBmb3Igc3RvcmluZyBpZGVudGlmaWNhdGlvbiBoaXN0b3J5XG4gKiBUaGlzIGlzIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIGFzIHBlciB0aGUgYmx1ZXByaW50IHJlcXVpcmVtZW50c1xuICovXG5cbi8vIE1heGltdW0gaGlzdG9yeSBpdGVtcyB0byBzdG9yZSAoZm9yIGZyZWUgdXNlcnMpXG5jb25zdCBNQVhfRlJFRV9ISVNUT1JZX0lURU1TID0gMTA7XG5cbi8vIEluLW1lbW9yeSBzdG9yYWdlIGZvciBpZGVudGlmaWNhdGlvbiBoaXN0b3J5XG5sZXQgaGlzdG9yeUl0ZW1zID0gW107XG5cbi8qKlxuICogQWRkIGEgbmV3IGlkZW50aWZpY2F0aW9uIHJlc3VsdCB0byBoaXN0b3J5XG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIFRoZSBpZGVudGlmaWNhdGlvbiByZXN1bHQgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUb0hpc3RvcnkoaXRlbSkge1xuICAvLyBBZGQgbmV3IGl0ZW0gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAgaGlzdG9yeUl0ZW1zLnVuc2hpZnQoaXRlbSk7XG4gIFxuICAvLyBMaW1pdCBoaXN0b3J5IHNpemUgZm9yIGZyZWUgdXNlcnNcbiAgaWYgKGhpc3RvcnlJdGVtcy5sZW5ndGggPiBNQVhfRlJFRV9ISVNUT1JZX0lURU1TKSB7XG4gICAgaGlzdG9yeUl0ZW1zID0gaGlzdG9yeUl0ZW1zLnNsaWNlKDAsIE1BWF9GUkVFX0hJU1RPUllfSVRFTVMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGhpc3RvcnkgaXRlbXMsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBGaWx0ZXIgdHlwZSAoJ3BsYW50JywgJ2FuaW1hbCcsIG9yICdhbGwnKVxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBoaXN0b3J5IGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIaXN0b3J5KHR5cGUgPSAnYWxsJykge1xuICBpZiAodHlwZSA9PT0gJ2FsbCcpIHtcbiAgICByZXR1cm4gWy4uLmhpc3RvcnlJdGVtc107XG4gIH1cbiAgXG4gIHJldHVybiBoaXN0b3J5SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS50eXBlID09PSB0eXBlKTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgaGlzdG9yeSBpdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBoaXN0b3J5SXRlbXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBzcGVjaWZpYyBoaXN0b3J5IGl0ZW0gYnkgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBJRCBvZiB0aGUgaGlzdG9yeSBpdGVtIHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBoaXN0b3J5IGl0ZW0gb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhpc3RvcnlCeUlkKGlkKSB7XG4gIHJldHVybiBoaXN0b3J5SXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGlkKSB8fCBudWxsO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHNwZWNpZmljIGhpc3RvcnkgaXRlbSBieSBJRFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBoaXN0b3J5IGl0ZW0gdG8gZGVsZXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBkZWxldGlvbiB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVIaXN0b3J5SXRlbShpZCkge1xuICBjb25zdCBpbml0aWFsTGVuZ3RoID0gaGlzdG9yeUl0ZW1zLmxlbmd0aDtcbiAgaGlzdG9yeUl0ZW1zID0gaGlzdG9yeUl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IGlkKTtcbiAgcmV0dXJuIGhpc3RvcnlJdGVtcy5sZW5ndGggIT09IGluaXRpYWxMZW5ndGg7XG59XG4iXSwibmFtZXMiOlsiTUFYX0ZSRUVfSElTVE9SWV9JVEVNUyIsImhpc3RvcnlJdGVtcyIsImFkZFRvSGlzdG9yeSIsIml0ZW0iLCJ1bnNoaWZ0IiwibGVuZ3RoIiwic2xpY2UiLCJnZXRIaXN0b3J5IiwidHlwZSIsImZpbHRlciIsImNsZWFySGlzdG9yeSIsImdldEhpc3RvcnlCeUlkIiwiaWQiLCJmaW5kIiwiZGVsZXRlSGlzdG9yeUl0ZW0iLCJpbml0aWFsTGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/memoryDb.js\n");

/***/ }),

/***/ "(api)/./utils/openRouterApi.js":
/*!********************************!*\
  !*** ./utils/openRouterApi.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   identifyWithOpenRouter: () => (/* binding */ identifyWithOpenRouter)\n/* harmony export */ });\n/**\n * Utility for interacting with the OpenRouter API to access deepseek-chat\n */ // The OpenRouter API endpoint\nconst OPENROUTER_API_ENDPOINT = \"https://openrouter.ai/api/v1/chat/completions\";\n/**\n * Sends an image to the OpenRouter API for identification\n * @param {string} imageData - Base64 encoded image data\n * @returns {Promise<Object>} Identification results\n */ async function identifyWithOpenRouter(imageData) {\n    try {\n        // Get API key from environment variable\n        const apiKey = \"\";\n        if (!apiKey) {\n            throw new Error(\"OpenRouter API key is not configured\");\n        }\n        // Check if we have valid image data\n        if (!imageData) {\n            throw new Error(\"No image was provided for analysis\");\n        }\n        console.log(\"Image data type:\", typeof imageData);\n        console.log(\"Image data starts with:\", imageData.substring(0, 50) + \"...\");\n        console.log(\"Image data length:\", imageData.length);\n        // Handle common image issues by testing different image formats\n        let imageUrl;\n        if (imageData.startsWith(\"http\")) {\n            // It's already a URL, use as is\n            imageUrl = imageData;\n            console.log(\"Using image URL directly\");\n        } else if (imageData.startsWith(\"data:image/\")) {\n            // It's already a data URL with correct format, use as is\n            imageUrl = imageData;\n            console.log(\"Using image data URL directly\");\n        } else if (imageData.startsWith(\"data:\")) {\n            // It's a data URL but might not have correct format\n            const contentType = imageData.split(\";\")[0].split(\":\")[1];\n            console.log(\"Content type detected:\", contentType);\n            if (!contentType || !contentType.startsWith(\"image/\")) {\n                // Fix content type if needed\n                console.log(\"Invalid content type, trying to fix\");\n                const base64Data = imageData.includes(\"base64,\") ? imageData.split(\"base64,\")[1] : imageData;\n                imageUrl = `data:image/jpeg;base64,${base64Data}`;\n            } else {\n                imageUrl = imageData;\n            }\n        } else {\n            // Assume it's raw base64 data and add the prefix\n            imageUrl = `data:image/jpeg;base64,${imageData}`;\n            console.log(\"Added data:image/jpeg prefix to base64 data\");\n        }\n        // Ensure valid URL format for OpenRouter API\n        if (!imageUrl) {\n            throw new Error(\"Failed to process image into valid format\");\n        }\n        // Prepare the prompt for identification\n        const prompt = `\n      I need you to carefully analyze this image and identify if it contains a plant or animal species.\n      \n      IMPORTANT: Be honest about your confidence level. If you're not very certain, use a lower confidence score (below 0.7).\n      If the image is unclear, low quality, or you can't identify the species with reasonable certainty, \n      admit this by using a low confidence score (0.3-0.5) and stating your uncertainty.\n      \n      Please provide:\n      - Category (plant or animal)\n      - Common name of the species (be specific)\n      - Scientific name (genus and species)\n      - Brief description (1-2 sentences about key identifying features)\n      - Additional relevant information (habitat, characteristics, interesting facts)\n      \n      Format your response as JSON with this structure:\n      {\n        \"identification\": {\n          \"category\": \"plant\" or \"animal\",\n          \"name\": \"Common name\",\n          \"scientificName\": \"Scientific name\",\n          \"confidence\": 0.3 to 0.95, // be honest about your confidence level\n          \"description\": \"Brief description of key features\",\n          \"additionalInfo\": {\n            \"habitat\": \"Where it's commonly found\",\n            \"characteristics\": \"Distinctive traits\",\n            \"notes\": \"Any uncertainty or limitations in your identification\"\n          }\n        }\n      }\n      \n      If you cannot confidently identify the species, indicate this in your response with lower confidence.\n    `;\n        // Make request to OpenRouter\n        const response = await fetch(OPENROUTER_API_ENDPOINT, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": `Bearer ${apiKey}`,\n                \"HTTP-Referer\": \"https://natureid.app\",\n                \"X-Title\": \"NatureID\"\n            },\n            body: JSON.stringify({\n                model: \"google/gemini-2.0-flash-exp:free\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: prompt\n                            },\n                            {\n                                type: \"image_url\",\n                                image_url: {\n                                    url: imageUrl\n                                }\n                            }\n                        ]\n                    }\n                ],\n                max_tokens: 1000,\n                response_format: {\n                    type: \"text\"\n                }\n            })\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"OpenRouter API error response:\", errorText);\n            try {\n                const errorData = JSON.parse(errorText);\n                throw new Error(errorData.error?.message || `OpenRouter API responded with status ${response.status}`);\n            } catch (parseError) {\n                throw new Error(`OpenRouter API error (${response.status}): ${errorText.slice(0, 100)}...`);\n            }\n        }\n        let data;\n        try {\n            const responseText = await response.text();\n            console.log(\"API response text:\", responseText.slice(0, 200) + \"...\");\n            data = JSON.parse(responseText);\n        } catch (parseError) {\n            console.error(\"Failed to parse API response:\", parseError);\n            throw new Error(\"Failed to parse API response\");\n        }\n        // Extract the content from the response\n        const content = data.choices[0]?.message?.content;\n        if (!content) {\n            throw new Error(\"Empty response from OpenRouter API\");\n        }\n        // Parse the JSON response\n        try {\n            // Find the JSON content (in case there's text around it)\n            const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n            if (!jsonMatch) {\n                throw new Error(\"Could not find JSON in the response\");\n            }\n            const identificationData = JSON.parse(jsonMatch[0]);\n            // Validate response format\n            if (!identificationData.identification) {\n                throw new Error(\"Invalid identification format in response\");\n            }\n            return identificationData;\n        } catch (parseError) {\n            console.error(\"Failed to parse identification data:\", parseError);\n            // Fallback response if parsing fails\n            return {\n                identification: {\n                    category: content.toLowerCase().includes(\"plant\") ? \"plant\" : \"animal\",\n                    name: \"Unknown Species\",\n                    scientificName: \"N/A\",\n                    confidence: 0.5,\n                    description: \"We could not properly identify this specimen. The AI provided a response but it was not in the expected format.\",\n                    additionalInfo: {\n                        note: \"The identification system encountered an issue. Try again with a clearer image.\"\n                    }\n                }\n            };\n        }\n    } catch (error) {\n        console.error(\"OpenRouter API error:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0Y7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFPckIsT0FBTztRQUNkOUIsUUFBUThCLE1BQU0seUJBQXlCQTtRQUN2QyxNQUFNQTtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3Jrc3BhY2UvLi91dGlscy9vcGVuUm91dGVyQXBpLmpzPzI1ODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBPcGVuUm91dGVyIEFQSSB0byBhY2Nlc3MgZGVlcHNlZWstY2hhdFxuICovXG5cbi8vIFRoZSBPcGVuUm91dGVyIEFQSSBlbmRwb2ludFxuY29uc3QgT1BFTlJPVVRFUl9BUElfRU5EUE9JTlQgPSAnaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zJztcblxuLyoqXG4gKiBTZW5kcyBhbiBpbWFnZSB0byB0aGUgT3BlblJvdXRlciBBUEkgZm9yIGlkZW50aWZpY2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VEYXRhIC0gQmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gSWRlbnRpZmljYXRpb24gcmVzdWx0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaWRlbnRpZnlXaXRoT3BlblJvdXRlcihpbWFnZURhdGEpIHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgQVBJIGtleSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuT1BFTlJPVVRFUl9BUElfS0VZO1xuICAgIFxuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5Sb3V0ZXIgQVBJIGtleSBpcyBub3QgY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmFsaWQgaW1hZ2UgZGF0YVxuICAgIGlmICghaW1hZ2VEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGltYWdlIHdhcyBwcm92aWRlZCBmb3IgYW5hbHlzaXMnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0ltYWdlIGRhdGEgdHlwZTonLCB0eXBlb2YgaW1hZ2VEYXRhKTtcbiAgICBjb25zb2xlLmxvZygnSW1hZ2UgZGF0YSBzdGFydHMgd2l0aDonLCBpbWFnZURhdGEuc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nKTtcbiAgICBjb25zb2xlLmxvZygnSW1hZ2UgZGF0YSBsZW5ndGg6JywgaW1hZ2VEYXRhLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gSGFuZGxlIGNvbW1vbiBpbWFnZSBpc3N1ZXMgYnkgdGVzdGluZyBkaWZmZXJlbnQgaW1hZ2UgZm9ybWF0c1xuICAgIGxldCBpbWFnZVVybDtcbiAgICBcbiAgICBpZiAoaW1hZ2VEYXRhLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgLy8gSXQncyBhbHJlYWR5IGEgVVJMLCB1c2UgYXMgaXNcbiAgICAgIGltYWdlVXJsID0gaW1hZ2VEYXRhO1xuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGltYWdlIFVSTCBkaXJlY3RseScpO1xuICAgIH0gZWxzZSBpZiAoaW1hZ2VEYXRhLnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UvJykpIHtcbiAgICAgIC8vIEl0J3MgYWxyZWFkeSBhIGRhdGEgVVJMIHdpdGggY29ycmVjdCBmb3JtYXQsIHVzZSBhcyBpc1xuICAgICAgaW1hZ2VVcmwgPSBpbWFnZURhdGE7XG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgaW1hZ2UgZGF0YSBVUkwgZGlyZWN0bHknKTtcbiAgICB9IGVsc2UgaWYgKGltYWdlRGF0YS5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAvLyBJdCdzIGEgZGF0YSBVUkwgYnV0IG1pZ2h0IG5vdCBoYXZlIGNvcnJlY3QgZm9ybWF0XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IGltYWdlRGF0YS5zcGxpdCgnOycpWzBdLnNwbGl0KCc6JylbMV07XG4gICAgICBjb25zb2xlLmxvZygnQ29udGVudCB0eXBlIGRldGVjdGVkOicsIGNvbnRlbnRUeXBlKTtcbiAgICAgIFxuICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgLy8gRml4IGNvbnRlbnQgdHlwZSBpZiBuZWVkZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgY29udGVudCB0eXBlLCB0cnlpbmcgdG8gZml4Jyk7XG4gICAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBpbWFnZURhdGEuaW5jbHVkZXMoJ2Jhc2U2NCwnKSA/IFxuICAgICAgICAgIGltYWdlRGF0YS5zcGxpdCgnYmFzZTY0LCcpWzFdIDogaW1hZ2VEYXRhO1xuICAgICAgICBpbWFnZVVybCA9IGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCR7YmFzZTY0RGF0YX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VVcmwgPSBpbWFnZURhdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFzc3VtZSBpdCdzIHJhdyBiYXNlNjQgZGF0YSBhbmQgYWRkIHRoZSBwcmVmaXhcbiAgICAgIGltYWdlVXJsID0gYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsJHtpbWFnZURhdGF9YDtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRlZCBkYXRhOmltYWdlL2pwZWcgcHJlZml4IHRvIGJhc2U2NCBkYXRhJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSB2YWxpZCBVUkwgZm9ybWF0IGZvciBPcGVuUm91dGVyIEFQSVxuICAgIGlmICghaW1hZ2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgaW1hZ2UgaW50byB2YWxpZCBmb3JtYXQnKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHRoZSBwcm9tcHQgZm9yIGlkZW50aWZpY2F0aW9uXG4gICAgY29uc3QgcHJvbXB0ID0gYFxuICAgICAgSSBuZWVkIHlvdSB0byBjYXJlZnVsbHkgYW5hbHl6ZSB0aGlzIGltYWdlIGFuZCBpZGVudGlmeSBpZiBpdCBjb250YWlucyBhIHBsYW50IG9yIGFuaW1hbCBzcGVjaWVzLlxuICAgICAgXG4gICAgICBJTVBPUlRBTlQ6IEJlIGhvbmVzdCBhYm91dCB5b3VyIGNvbmZpZGVuY2UgbGV2ZWwuIElmIHlvdSdyZSBub3QgdmVyeSBjZXJ0YWluLCB1c2UgYSBsb3dlciBjb25maWRlbmNlIHNjb3JlIChiZWxvdyAwLjcpLlxuICAgICAgSWYgdGhlIGltYWdlIGlzIHVuY2xlYXIsIGxvdyBxdWFsaXR5LCBvciB5b3UgY2FuJ3QgaWRlbnRpZnkgdGhlIHNwZWNpZXMgd2l0aCByZWFzb25hYmxlIGNlcnRhaW50eSwgXG4gICAgICBhZG1pdCB0aGlzIGJ5IHVzaW5nIGEgbG93IGNvbmZpZGVuY2Ugc2NvcmUgKDAuMy0wLjUpIGFuZCBzdGF0aW5nIHlvdXIgdW5jZXJ0YWludHkuXG4gICAgICBcbiAgICAgIFBsZWFzZSBwcm92aWRlOlxuICAgICAgLSBDYXRlZ29yeSAocGxhbnQgb3IgYW5pbWFsKVxuICAgICAgLSBDb21tb24gbmFtZSBvZiB0aGUgc3BlY2llcyAoYmUgc3BlY2lmaWMpXG4gICAgICAtIFNjaWVudGlmaWMgbmFtZSAoZ2VudXMgYW5kIHNwZWNpZXMpXG4gICAgICAtIEJyaWVmIGRlc2NyaXB0aW9uICgxLTIgc2VudGVuY2VzIGFib3V0IGtleSBpZGVudGlmeWluZyBmZWF0dXJlcylcbiAgICAgIC0gQWRkaXRpb25hbCByZWxldmFudCBpbmZvcm1hdGlvbiAoaGFiaXRhdCwgY2hhcmFjdGVyaXN0aWNzLCBpbnRlcmVzdGluZyBmYWN0cylcbiAgICAgIFxuICAgICAgRm9ybWF0IHlvdXIgcmVzcG9uc2UgYXMgSlNPTiB3aXRoIHRoaXMgc3RydWN0dXJlOlxuICAgICAge1xuICAgICAgICBcImlkZW50aWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcImNhdGVnb3J5XCI6IFwicGxhbnRcIiBvciBcImFuaW1hbFwiLFxuICAgICAgICAgIFwibmFtZVwiOiBcIkNvbW1vbiBuYW1lXCIsXG4gICAgICAgICAgXCJzY2llbnRpZmljTmFtZVwiOiBcIlNjaWVudGlmaWMgbmFtZVwiLFxuICAgICAgICAgIFwiY29uZmlkZW5jZVwiOiAwLjMgdG8gMC45NSwgLy8gYmUgaG9uZXN0IGFib3V0IHlvdXIgY29uZmlkZW5jZSBsZXZlbFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJCcmllZiBkZXNjcmlwdGlvbiBvZiBrZXkgZmVhdHVyZXNcIixcbiAgICAgICAgICBcImFkZGl0aW9uYWxJbmZvXCI6IHtcbiAgICAgICAgICAgIFwiaGFiaXRhdFwiOiBcIldoZXJlIGl0J3MgY29tbW9ubHkgZm91bmRcIixcbiAgICAgICAgICAgIFwiY2hhcmFjdGVyaXN0aWNzXCI6IFwiRGlzdGluY3RpdmUgdHJhaXRzXCIsXG4gICAgICAgICAgICBcIm5vdGVzXCI6IFwiQW55IHVuY2VydGFpbnR5IG9yIGxpbWl0YXRpb25zIGluIHlvdXIgaWRlbnRpZmljYXRpb25cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBJZiB5b3UgY2Fubm90IGNvbmZpZGVudGx5IGlkZW50aWZ5IHRoZSBzcGVjaWVzLCBpbmRpY2F0ZSB0aGlzIGluIHlvdXIgcmVzcG9uc2Ugd2l0aCBsb3dlciBjb25maWRlbmNlLlxuICAgIGA7XG5cbiAgICAvLyBNYWtlIHJlcXVlc3QgdG8gT3BlblJvdXRlclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goT1BFTlJPVVRFUl9BUElfRU5EUE9JTlQsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthcGlLZXl9YCxcbiAgICAgICAgJ0hUVFAtUmVmZXJlcic6ICdodHRwczovL25hdHVyZWlkLmFwcCcsIC8vIFJlcGxhY2Ugd2l0aCB5b3VyIGFjdHVhbCBhcHAgVVJMXG4gICAgICAgICdYLVRpdGxlJzogJ05hdHVyZUlEJ1xuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbW9kZWw6ICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaC1leHA6ZnJlZScsXG4gICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdGV4dDogcHJvbXB0IH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2VfdXJsJyxcbiAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgIHVybDogaW1hZ2VVcmxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG1heF90b2tlbnM6IDEwMDAsXG4gICAgICAgIHJlc3BvbnNlX2Zvcm1hdDogeyB0eXBlOiBcInRleHRcIiB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcihcIk9wZW5Sb3V0ZXIgQVBJIGVycm9yIHJlc3BvbnNlOlwiLCBlcnJvclRleHQpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgXG4gICAgICAgICAgYE9wZW5Sb3V0ZXIgQVBJIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlblJvdXRlciBBUEkgZXJyb3IgKCR7cmVzcG9uc2Uuc3RhdHVzfSk6ICR7ZXJyb3JUZXh0LnNsaWNlKDAsIDEwMCl9Li4uYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQVBJIHJlc3BvbnNlIHRleHQ6XCIsIHJlc3BvbnNlVGV4dC5zbGljZSgwLCAyMDApICsgXCIuLi5cIik7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgQVBJIHJlc3BvbnNlOlwiLCBwYXJzZUVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBBUEkgcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4dHJhY3QgdGhlIGNvbnRlbnQgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICBjb25zdCBjb250ZW50ID0gZGF0YS5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50O1xuICAgIFxuICAgIGlmICghY29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSByZXNwb25zZSBmcm9tIE9wZW5Sb3V0ZXIgQVBJJyk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIEpTT04gcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgLy8gRmluZCB0aGUgSlNPTiBjb250ZW50IChpbiBjYXNlIHRoZXJlJ3MgdGV4dCBhcm91bmQgaXQpXG4gICAgICBjb25zdCBqc29uTWF0Y2ggPSBjb250ZW50Lm1hdGNoKC9cXHtbXFxzXFxTXSpcXH0vKTtcbiAgICAgIGlmICghanNvbk1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgSlNPTiBpbiB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgaWRlbnRpZmljYXRpb25EYXRhID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSByZXNwb25zZSBmb3JtYXRcbiAgICAgIGlmICghaWRlbnRpZmljYXRpb25EYXRhLmlkZW50aWZpY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpZGVudGlmaWNhdGlvbiBmb3JtYXQgaW4gcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkZW50aWZpY2F0aW9uRGF0YTtcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgaWRlbnRpZmljYXRpb24gZGF0YTonLCBwYXJzZUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgcmVzcG9uc2UgaWYgcGFyc2luZyBmYWlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmljYXRpb246IHtcbiAgICAgICAgICBjYXRlZ29yeTogY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwbGFudCcpID8gJ3BsYW50JyA6ICdhbmltYWwnLFxuICAgICAgICAgIG5hbWU6ICdVbmtub3duIFNwZWNpZXMnLFxuICAgICAgICAgIHNjaWVudGlmaWNOYW1lOiAnTi9BJyxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdXZSBjb3VsZCBub3QgcHJvcGVybHkgaWRlbnRpZnkgdGhpcyBzcGVjaW1lbi4gVGhlIEFJIHByb3ZpZGVkIGEgcmVzcG9uc2UgYnV0IGl0IHdhcyBub3QgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdC4nLFxuICAgICAgICAgIGFkZGl0aW9uYWxJbmZvOiB7XG4gICAgICAgICAgICBub3RlOiAnVGhlIGlkZW50aWZpY2F0aW9uIHN5c3RlbSBlbmNvdW50ZXJlZCBhbiBpc3N1ZS4gVHJ5IGFnYWluIHdpdGggYSBjbGVhcmVyIGltYWdlLidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ09wZW5Sb3V0ZXIgQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk9QRU5ST1VURVJfQVBJX0VORFBPSU5UIiwiaWRlbnRpZnlXaXRoT3BlblJvdXRlciIsImltYWdlRGF0YSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOUk9VVEVSX0FQSV9LRVkiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJpbWFnZVVybCIsInN0YXJ0c1dpdGgiLCJjb250ZW50VHlwZSIsInNwbGl0IiwiYmFzZTY0RGF0YSIsImluY2x1ZGVzIiwicHJvbXB0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInR5cGUiLCJ0ZXh0IiwiaW1hZ2VfdXJsIiwidXJsIiwibWF4X3Rva2VucyIsInJlc3BvbnNlX2Zvcm1hdCIsIm9rIiwiZXJyb3JUZXh0IiwiZXJyb3IiLCJlcnJvckRhdGEiLCJwYXJzZSIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJwYXJzZUVycm9yIiwic2xpY2UiLCJkYXRhIiwicmVzcG9uc2VUZXh0IiwiY2hvaWNlcyIsImpzb25NYXRjaCIsIm1hdGNoIiwiaWRlbnRpZmljYXRpb25EYXRhIiwiaWRlbnRpZmljYXRpb24iLCJjYXRlZ29yeSIsInRvTG93ZXJDYXNlIiwibmFtZSIsInNjaWVudGlmaWNOYW1lIiwiY29uZmlkZW5jZSIsImRlc2NyaXB0aW9uIiwiYWRkaXRpb25hbEluZm8iLCJub3RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/openRouterApi.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/identify.js"));
module.exports = __webpack_exports__;

})();